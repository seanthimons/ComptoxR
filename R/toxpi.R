#' ToxPi Single Endpoint score calculation
#'
#' @details The back_fill argument is used to specify how to handle missing, `NA`, and zero-ed out data.
#'
#' @param x Takes a single column for calculation of a normalization score
#' @param back_fill Argument to specify for back-filling missing data

#' @return A vector
#' @export

tp_single_score <- function(x, back_fill){


  df <- (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))

  if(is.null(back_fill)){
    #Catches from tp_combined_score
  }else{
  if(!missing(back_fill)){
    back_fill <- match.arg(back_fill, c('min', 'mean', 'max', 'half_min'))

    if(back_fill == 'min'){
      df[df == 0] <- min(df[df > 0], na.rm = T)
    }else{
      if(back_fill == 'mean'){
        df[df == 0] <- mean(df[df > 0], na.rm = T)
      }else{
        if(back_fill == 'max'){
          df[df == 0] <- max(df[df > 0], na.rm = T)
        }else{
          if(back_fill == 'half_min'){
            df[df == 0] <- min(df[df > 0], na.rm = T)*0.5
          }
        }
      }
    }
  }
}

  return(df)
}

#' ToxPi Combined Score Table
#'
#' Takes a user-supplied table (with a column that provides identification), and optionally a bias table from [hc_endpoint_coverage()] with user-supplied weights. The function will perform a min-max normalization per each endpoint (i.e.: every other column that is not an identifier), then sums up the scores on a per-row basis.
#' The suggested workflow is to create the bias table, then to run the function with the desired table to evaluate.
#'
#' @param table A table that contains an id column and endpoints to weigh against.
#' @param id id column to ignore. Must be present to continue calculation.
#' @param bias A table generated by the user using the [tp_endpoint_coverage()] function. Required for calculation.
#' @param back_fill Variable to pass along to [tp_single_score()]

#'
#' @return A tibble of results
#' @export

tp_combined_score <- function(table, id = NULL, bias = NULL, back_fill){

  if(missing(table)) cli_abort('No table present!')

  if(is.null(id) == TRUE){
    id <- colnames(table[1,1])

    cli_alert_warning(cat(col_yellow('Defaulting to first column for id: {id}')))

    }
  if(is.null(bias) == TRUE){


    cli_alert_warning(
        col_yellow('WARNING:
                   No bias table detected, defaulting to filter = 0.5!
                   Did you know about `hc_endpoint_coverage()`?'
          ))

      bias <- tp_endpoint_coverage(table, id, suffix = NA, filter = 0.5)
      print(bias)
      cat('\n')
    }

    tp <- table %>% select(c(id,bias$endpoint))

    bias <- bias %>%
      select(endpoint, weight) %>%
      pivot_wider(names_from = endpoint,
                  values_from = weight)

    if(missing(back_fill) == TRUE){cli_alert_warning('No back filling option specified!')
      back_fill <- NULL
      }else{
      cli_alert_warning('Back filling option selected: {back_fill}')
    }

    tp_scores <- tp %>%
      #removes INF
      mutate(across(.cols = everything(), ~ ifelse(is.infinite(.x), 0, .x))) %>%
      #tie breaking logic needed here....
      mutate(across(.cols = !contains(id),
                    ~{if(length(na.omit(.)) == 1){
                      ifelse(is.na(.x) == TRUE, 0, 1)
                    }else{
                      if(sd(na.omit(.)) == 0){
                        ifelse(is.na(.), NA, 1)
                      }else{tp_single_score(., back_fill) %>% round(digits = 4)}

                    }})) %>%
      mutate(across(where(is.numeric), ~replace_na(.,0)))

    tp_names <- tp_scores[,id]

    tp_scores <- data.frame(mapply('*',tp_scores[,2:ncol(tp_scores)], bias)) %>% as_tibble()

    tp_scores <- cbind(tp_names, tp_scores)

    tp_scores <- tp_scores %>%
      rowwise() %>%
      mutate(score = sum(c_across(cols = !contains(id)))) %>%
      relocate(score, .after = id) %>%
      arrange(desc(score))

  return(tp_scores)
}



