#' ToxPi Single Endpoint score calculation
#'
#' @param x Takes a single column for calculation a normalization score
#' @param min_fill Boolean variable for adding in 50% to lowest non-zero score. Defaults to `TRUE`
#'
#' @return A vector
#' @export

tp_single_score <- function(x, min_fill = T){

  df <- (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))
  if(min_fill == T)
    {df[df == 0] <- min(df[df > 0], na.rm = T)*0.5}
  else{}
  return(df)
}



#' ToxPi Combined Score Table
#'
#' Takes a user-supplied table (with a column that provides identification), and optionally a bias table from [hc_endpoint_coverage()] with user-supplied weights. The function will perform a min-max normalization per each endpoint (i.e.: every other column that is not an identifier), then sums up the scores on a per-row basis.
#' The suggested workflow is to create the bias table, then to run the function with the desired table to evaluate.
#'
#' @param table A table that contains an ID column and endpoints to weigh against.
#' @param ID ID column to ignore. Must be present to continue calculation.
#' @param bias A table generated by the user using the [hc_endpoint_coverage()] function. Required for calculation.
#' @param ... Variable to pass in min_fill argument
#'
#' @return A tibble of results
#' @export

tp_combined_score <- function(table, ID = NULL, bias = NULL, ...){

  if(is.null(ID) == TRUE){
    ID <- colnames(table[1,1])
    cat(cat('\nDefaulting to first column for ID: '),ID,'\n')
    }
  if(is.null(bias) == TRUE){
      cat('\nNo bias table detected, defaulting to filter = 0.1!\nDid you know about `hc_endpoint_coverage()`?\n')

      bias <- hc_endpoint_coverage(table, ID, suffix = '_amount', filter = 0.1)
      print(bias)
      cat('\n')
    }

    tp <- table %>% select(c(ID,bias$endpoint))

    bias <- bias %>%
      select(endpoint, weight) %>%
      pivot_wider(names_from = endpoint,
                  values_from = weight)

    tp_scores <- tp %>%
      mutate(across(.cols = !contains(ID),
                    ~ if(sd(na.omit(.)) == 0)
                    {ifelse(is.na(.), NA, 1)}
                    else {tp_single_score(., ...) %>% round(digits = 4)
                    })) %>%
      mutate(across(where(is.numeric), ~replace_na(.,0)))

    tp_names <- tp_scores[,ID]

    tp_scores <- data.frame(mapply('*',tp_scores[,2:ncol(tp_scores)], bias)) %>% as_tibble()

    tp_scores <- cbind(tp_names, tp_scores)

    tp_scores <- tp_scores %>%
      rowwise() %>%
      mutate(score = sum(c_across(cols = !contains(ID))))

  return(tp_scores)
}
