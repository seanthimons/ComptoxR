#' ToxPi Single Endpoint score calculation
#'
#' @details The back_fill argument is used to specify how to handle missing and zero-ed out data.
#'
#' @param x Takes a single column for calculation a normalization score
#' @param back_fill Argument to specify for back-filling missing data

#' @return A vector
#' @export

tp_single_score <- function(x, back_fill){


  df <- (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))

  if(!missing(back_fill)){
    back_fill <- match.arg(back_fill, c('min', 'mean', 'max', 'half_min'))

    if(back_fill == 'min'){
      df[df == 0] <- min(df[df > 0], na.rm = T)
    }else{
      if(back_fill == 'mean'){
        df[df == 0] <- mean(df[df > 0], na.rm = T)
      }else{
        if(back_fill == 'max'){
          df[df == 0] <- max(df[df > 0], na.rm = T)
        }else{
          if(back_fill == 'half_min'){
            df[df == 0] <- min(df[df > 0], na.rm = T)*0.5
          }
        }
      }
    }
  }else{}


  return(df)
}

#' ToxPi Combined Score Table
#'
#' Takes a user-supplied table (with a column that provides identification), and optionally a bias table from [hc_endpoint_coverage()] with user-supplied weights. The function will perform a min-max normalization per each endpoint (i.e.: every other column that is not an identifier), then sums up the scores on a per-row basis.
#' The suggested workflow is to create the bias table, then to run the function with the desired table to evaluate.
#'
#' @param table A table that contains an ID column and endpoints to weigh against.
#' @param ID ID column to ignore. Must be present to continue calculation.
#' @param bias A table generated by the user using the [hc_endpoint_coverage()] function. Required for calculation.
#' @param ... Variable to pass in min_fill argument
#'
#' @return A tibble of results
#' @export

tp_combined_score <- function(table, ID = NULL, bias = NULL, ...){

  if(is.null(ID) == TRUE){
    ID <- colnames(table[1,1])
    cat(cat('\nDefaulting to first column for ID: '),ID,'\n')
    }
  if(is.null(bias) == TRUE){
      cat(colorize('\nNo bias table detected, defaulting to filter = 0.1!\nDid you know about `hc_endpoint_coverage()`?\n', fg ='yellow'))

      bias <- hc_endpoint_coverage(table, ID, suffix = '_amount', filter = 0.1)
      print(bias)
      cat('\n')
    }

    tp <- table %>% select(c(ID,bias$endpoint))

    bias <- bias %>%
      select(endpoint, weight) %>%
      pivot_wider(names_from = endpoint,
                  values_from = weight)

    tp_scores <- tp %>%
      #removes INF
      mutate(across(.cols = everything(), ~ ifelse(is.infinite(.x), 0, .x))) %>%
      #tie breaking logic needed here....
      mutate(across(.cols = !contains(ID),
                    ~{if(length(na.omit(.)) == 1){
                      ifelse(is.na(.x) == TRUE, 0, 1)
                    }else{
                      if(sd(na.omit(.)) == 0){
                        ifelse(is.na(.), NA, 1)
                      }else{tp_single_score(., ...) %>% round(digits = 4)}

                    }})) %>%
      mutate(across(where(is.numeric), ~replace_na(.,0)))

    tp_names <- tp_scores[,ID]

    tp_scores <- data.frame(mapply('*',tp_scores[,2:ncol(tp_scores)], bias)) %>% as_tibble()

    tp_scores <- cbind(tp_names, tp_scores)

    tp_scores <- tp_scores %>%
      rowwise() %>%
      mutate(score = sum(c_across(cols = !contains(ID))))

  return(tp_scores)
}
