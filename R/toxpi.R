#' ToxPi Single Endpoint score calculation
#'
#' @details The back_fill argument is used to specify how to handle missing, `NA`, and zero-ed out data.
#'
#' @param x Takes a single column for calculation of a normalization score
#' @param back_fill Argument to specify for back-filling missing data

#' @return A vector
#' @export

tp_single_score <- function(x, back_fill){


  df <- (x - min(x, na.rm = TRUE))/diff(range(x, na.rm = TRUE))

  if(is.null(back_fill)){
    #Catches from tp_combined_score
  }else{
  if(!missing(back_fill)){
    back_fill <- match.arg(back_fill, c('min', 'mean', 'max', 'half_min'))

    if(back_fill == 'min'){
      df[df == 0] <- min(df[df > 0], na.rm = T)
    }else{
      if(back_fill == 'mean'){
        df[df == 0] <- mean(df[df > 0], na.rm = T)
      }else{
        if(back_fill == 'max'){
          df[df == 0] <- max(df[df > 0], na.rm = T)
        }else{
          if(back_fill == 'half_min'){
            df[df == 0] <- min(df[df > 0], na.rm = T)*0.5
          }
        }
      }
    }
  }
}

  return(df)
}

#' ToxPi Combined Score Table
#'
#' Takes a user-supplied table (with a column that provides identification), and optionally a bias table from [hc_endpoint_coverage()] with user-supplied weights. The function will perform a min-max normalization per each endpoint (i.e.: every other column that is not an identifier), then sums up the scores on a per-row basis.
#' The suggested workflow is to create the bias table, then to run the function with the desired table to evaluate.
#'
#' @param table A table that contains an id column and endpoints to weigh against.
#' @param id id column to ignore. Must be present to continue calculation.
#' @param bias A table generated by the user using the [tp_endpoint_coverage()] function. Required for calculation.
#' @param back_fill Variable to pass along to [tp_single_score()]

#'
#' @return A tibble of results
#' @export

tp_combined_score <- function(table, id = NULL, bias = NULL, back_fill){

  if(missing(table)) cli_abort('No table present!')

  cat_line()
  cli_rule(left = 'ID variable')

  if(is.null(id) == TRUE){
    id <- colnames(table[1,1])

    cli_alert_warning((col_yellow('Defaulting to first column for id: {id}')))

  }

  cat_line()

  tp_list <- list(tp_scores = NULL, bias = NULL, variable_coverage = NULL)

  #Bias table----
  cli_rule(left = 'Bias table')
  cat_line()

  if(is.null(bias) == TRUE){
    cli_alert_warning(
        col_yellow('WARNING:
                   No bias table detected, defaulting to filter = 0.5!
                   Did you know about `tp_endpoint_coverage()`?
                   '
          ))

      bias <- tp_endpoint_coverage(table, id, suffix = NA, filter = 0.5)
      bias %>% print(n = Inf)
    tp_list$bias <- bias
  }else{
    bias %>% print(n = Inf)
    tp_list$bias <- bias
    }

  cat_line()

  tp <- table %>% select(c(id,bias$endpoint))

  bias <- bias %>%
      select(endpoint, weight) %>%
      pivot_wider(names_from = endpoint,
                  values_from = weight)

  #Variable coverage----

  cli_rule(left = 'Variable data coverage')
  tp_list$variable_coverage <- tp_variable_coverage(table = table, id = id )
  tp_list$variable_coverage %>% print(n = Inf)

  cat_line()
  cli_rule()


  #Backfilling----

    if(missing(back_fill) == TRUE){cli_alert_warning('No back filling option specified!')
      back_fill <- NULL
      }else{
      cli_alert_warning('Back filling option selected: {back_fill}')
      }
    cat_line()

#TP scores----
    tp_scores <- tp %>%
      #removes INF
      mutate(across(.cols = everything(), ~ ifelse(is.infinite(.x), 0, .x))) %>%
      #tie breaking logic needed here....
      mutate(across(.cols = !contains(id),
                    ~{if(length(na.omit(.)) == 1){
                      ifelse(is.na(.x) == TRUE, 0, 1)
                    }else{
                      if(sd(na.omit(.)) == 0){
                        ifelse(is.na(.), NA, 1)
                      }else{tp_single_score(., back_fill) %>% round(digits = 4)}

                    }})) %>%
      mutate(across(where(is.numeric), ~replace_na(.,0)))

    tp_names <- tp_scores[,id]

    tp_scores <- data.frame(mapply('*',tp_scores[,2:ncol(tp_scores)], bias)) %>% as_tibble()

    tp_scores <- cbind(tp_names, tp_scores)

    tp_scores <- tp_scores %>%
      rowwise() %>%
      mutate(score = sum(c_across(cols = !contains(id)))) %>%
      relocate(score, .after = id) %>%
      arrange(desc(score)) %>%
      ungroup()


    tp_list$tp_scores <- tp_scores

  return(tp_list)
}

#' ToxPi scatterplot
#'
#' @param toxpi_list
#'
#' @return A plot
#' @export

tp_plot <- function(toxpi_list){

  var <- toxpi_list$toxpi$variable_coverage
  tp <- toxpi_list$toxpi$tp_scores

  plot <- tp %>%
    arrange(score) %>%
    left_join(., var, by = 'dtxsid') %>%
    select(dtxsid, score, data_coverage) %>%
    mutate(dtxsid = forcats::fct_reorder(dtxsid, score)) %>%
    ggplot(mapping = aes(
      x = dtxsid,
      y = score,
      color = data_coverage
    )) +
    geom_point(
      size = 1.5
    ) +
    scale_color_continuous(type = "viridis") +
    coord_flip() +
    t

 return(plot)
}

