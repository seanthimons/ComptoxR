---
phase: 26-pagination-tests-coverage-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dev/endpoint_eval/04_openapi_parser.R
  - tests/testthat/test-pagination-detection.R
autonomous: true
requirements: [PAG-20]
must_haves:
  truths:
    - "All 7 PAGINATION_REGISTRY patterns are correctly detected from real schema data"
    - "Non-paginated endpoints return strategy 'none' with no false positives"
    - "detect_pagination() warns when params resemble pagination but match no registry entry"
  artifacts:
    - path: "tests/testthat/test-pagination-detection.R"
      provides: "Unit tests for pagination regex detection"
      min_lines: 80
    - path: "dev/endpoint_eval/04_openapi_parser.R"
      provides: "Enhanced detect_pagination with warning for unmatched pagination-like params"
      contains: "cli::cli_warn"
  key_links:
    - from: "tests/testthat/test-pagination-detection.R"
      to: "dev/endpoint_eval/04_openapi_parser.R"
      via: "source() at top of test file"
      pattern: "source.*04_openapi_parser"
    - from: "tests/testthat/test-pagination-detection.R"
      to: "dev/endpoint_eval/00_config.R"
      via: "source() to load PAGINATION_REGISTRY"
      pattern: "source.*00_config"
---

<objective>
Create unit tests for pagination pattern detection and enhance detect_pagination() with a warning for unmatched pagination-like parameters.

Purpose: Verify that all 7 PAGINATION_REGISTRY patterns are correctly identified from real schema data (PAG-20), including negative tests for non-paginated endpoints.
Output: test-pagination-detection.R test file, enhanced detect_pagination() function
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-pagination-tests-coverage-hardening/26-CONTEXT.md
@.planning/phases/26-pagination-tests-coverage-hardening/26-RESEARCH.md

<interfaces>
<!-- detect_pagination signature and return structure from dev/endpoint_eval/04_openapi_parser.R -->

```r
# Function signature (line 321-322):
detect_pagination <- function(route, path_params, query_params, body_params,
                              registry = PAGINATION_REGISTRY)

# Returns a list:
# On match:
list(
  strategy = "offset_limit"|"cursor"|"page_number"|"page_size",
  registry_key = "offset_limit_path"|"cursor_path"|"page_number_query"|...,
  params = c("limit", "offset"),
  param_location = "path"|"query"|"body",
  description = "..."
)

# On no match:
list(
  strategy = "none",
  registry_key = NA_character_,
  params = character(0),
  param_location = NA_character_,
  description = "No pagination detected"
)
```

<!-- PAGINATION_REGISTRY from dev/endpoint_eval/00_config.R (7 entries): -->
```r
PAGINATION_REGISTRY <- list(
  offset_limit_path = list(strategy="offset_limit", route_pattern="_pagination/\\{[^}]+\\}/\\{[^}]+\\}$", param_names=c("limit","offset"), param_location="path"),
  cursor_path = list(strategy="cursor", route_pattern="_keyset_pagination/\\{[^}]+\\}$", param_names=c("limit","cursor"), param_location=c("path","query")),
  page_number_query = list(strategy="page_number", route_pattern=NULL, param_names=c("pageNumber"), param_location="query"),
  offset_size_body = list(strategy="offset_limit", route_pattern=NULL, param_names=c("offset","limit"), param_location="body"),
  offset_size_query = list(strategy="offset_limit", route_pattern=NULL, param_names=c("offset","size"), param_location="query"),
  page_size_query = list(strategy="page_size", route_pattern=NULL, param_names=c("page","size"), param_location="query"),
  page_items_query = list(strategy="page_size", route_pattern=NULL, param_names=c("page","itemsPerPage"), param_location="query")
)
```

<!-- detect_pagination function body: lines 321-388 of 04_openapi_parser.R -->
<!-- Key logic: iterates registry entries, checks route_pattern first (if set), then matches param_names against the correct param vector based on param_location -->
<!-- Cursor is special-cased: needs "limit" in path AND "cursor" in query -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance detect_pagination with warning for unmatched pagination-like params</name>
  <files>dev/endpoint_eval/04_openapi_parser.R</files>
  <action>
In the `detect_pagination()` function (line 321-388), add a heuristic check BEFORE the "No match found" return block (line 380-388). The enhancement:

1. Define a set of pagination-like parameter names: `c("page", "pageNumber", "pageSize", "offset", "limit", "size", "cursor", "itemsPerPage", "skip", "top", "after", "before", "startIndex", "count")`
2. Check if ANY of the route/path/query/body params contain pagination-like names
3. If yes (params look like pagination but no registry match), emit a warning using `cli::cli_warn()`:
   ```r
   cli::cli_warn(c(
     "Parameters resemble pagination but no registry pattern matched.",
     "i" = "Route: {.val {route}}",
     "i" = "Suspicious params: {.val {suspicious}}",
     "i" = "Consider adding a new entry to PAGINATION_REGISTRY in 00_config.R"
   ))
   ```
4. Still return `strategy = "none"` (behavior unchanged, just adds informational warning)
5. Add the `suspicious` variable as the intersection of all params with the pagination-like set

This ensures `cli` package is available (already in Imports). Do NOT change any existing matching logic.
  </action>
  <verify>
```bash
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('dev/endpoint_eval/00_config.R'); source('dev/endpoint_eval/04_openapi_parser.R'); r <- detect_pagination('/test', 'skip', '', ''); stopifnot(r$strategy == 'none'); cat('Enhancement works\n')"
```
  </verify>
  <done>detect_pagination() emits a cli::cli_warn when params resemble pagination but match no registry entry, still returns strategy "none"</done>
</task>

<task type="auto">
  <name>Task 2: Create test-pagination-detection.R with full registry coverage and negative tests</name>
  <files>tests/testthat/test-pagination-detection.R</files>
  <action>
Create `tests/testthat/test-pagination-detection.R` with the following structure:

**Setup block** (top of file):
```r
# Source dev/ dependencies (not part of package namespace)
source(here::here("dev/endpoint_eval/00_config.R"))
source(here::here("dev/endpoint_eval/04_openapi_parser.R"))
```

**Test 1: Registry structure** — Verify PAGINATION_REGISTRY has exactly 7 entries with expected names: "offset_limit_path", "cursor_path", "page_number_query", "offset_size_body", "offset_size_query", "page_size_query", "page_items_query". Use `expect_equal(length(...), 7)` and `expect_named()`.

**Test 2: All 7 patterns detected** — For each registry entry, call `detect_pagination()` with matching route/params:
- offset_limit_path: route="/amos/method_pagination/{limit}/{offset}", path_params="limit,offset" → expect strategy="offset_limit", registry_key="offset_limit_path"
- cursor_path: route="/amos/similar_structures_keyset_pagination/{limit}", path_params="limit", query_params="cursor" → expect strategy="cursor", registry_key="cursor_path"
- page_number_query: route="/hazard", query_params="pageNumber" → expect strategy="page_number", registry_key="page_number_query"
- offset_size_body: route="/search", body_params="offset,limit" → expect strategy="offset_limit", registry_key="offset_size_body"
- offset_size_query: route="/search", query_params="offset,size" → expect strategy="offset_limit", registry_key="offset_size_query"
- page_size_query: route="/resolver/classyfire", query_params="page,size" → expect strategy="page_size", registry_key="page_size_query"
- page_items_query: route="/resolver/pubchem", query_params="page,itemsPerPage" → expect strategy="page_size", registry_key="page_items_query"

**Test 3: Negative tests (no false positives)** — Verify these return strategy="none":
- Single-item GET: route="/chemical/detail/{dtxsid}", path_params="dtxsid"
- Bulk POST without pagination: route="/hazard", query_params="projection"
- Empty params: route="/status", all params empty strings

**Test 4: Dynamic schema validation** — Wrap in `skip()` if schema dir missing:
```r
test_that("detect_pagination matches patterns found in real schema files", {
  schema_dir <- here::here("schema")
  if (!dir.exists(schema_dir)) skip("Schema directory not available")

  # Find any schema with "pagination" in endpoint paths
  schema_files <- list.files(schema_dir, pattern = "\\.json$", full.names = TRUE)
  expect_true(length(schema_files) > 0, info = "Schema directory has JSON files")

  # Load one AMOS schema and verify pagination endpoint detected
  amos_files <- schema_files[grepl("amos", schema_files, ignore.case = TRUE)]
  if (length(amos_files) == 0) skip("No AMOS schema file found")

  amos <- jsonlite::read_json(amos_files[1])
  routes <- names(amos$paths)
  pag_routes <- routes[grepl("pagination", routes)]
  expect_true(length(pag_routes) > 0, info = "AMOS schema has pagination endpoints")

  # Verify at least one pagination route is detected
  for (route in pag_routes) {
    # Extract path param names from {param} patterns
    path_names <- regmatches(route, gregexpr("\\{([^}]+)\\}", route))[[1]]
    path_names <- gsub("[{}]", "", path_names)

    result <- detect_pagination(
      route = route,
      path_params = paste(path_names, collapse = ","),
      query_params = "",
      body_params = ""
    )
    # At least some should be detected (not all may be — that's ok)
  }
})
```

**Test 5: Warning for unmatched pagination-like params** — Call detect_pagination with params that look like pagination but don't match any registry entry (e.g., route="/custom", query_params="skip,top"). Use `expect_warning()` to verify the warning is emitted, and verify the result still returns strategy="none".

All empty-string params should be passed as `""` not `NULL` (matching the function's split_params behavior).
  </action>
  <verify>
```bash
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pagination-detection.R')"
```
  </verify>
  <done>All detection tests pass: 7 registry patterns verified, negative tests confirm no false positives, dynamic schema test runs (or skips gracefully), warning test confirms enhancement works</done>
</task>

</tasks>

<verification>
```bash
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pagination-detection.R')"
```
All tests pass. No changes to existing test files (regression check deferred to Plan 02).
</verification>

<success_criteria>
- test-pagination-detection.R exists with tests covering all 7 PAGINATION_REGISTRY patterns
- Negative tests confirm non-paginated endpoints return strategy "none"
- detect_pagination() warns for unmatched pagination-like parameters
- Dynamic schema test runs against real schema files (or skips if schemas unavailable)
</success_criteria>

<output>
After completion, create `.planning/phases/26-pagination-tests-coverage-hardening/26-01-SUMMARY.md`
</output>
