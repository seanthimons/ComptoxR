---
phase: 26-pagination-tests-coverage-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - DESCRIPTION
  - tests/testthat/test-pagination-execution.R
  - tests/testthat/test-pagination-integration.R
  - .github/workflows/coverage-check.yml
autonomous: true
requirements: [PAG-21, PAG-22, PAG-23]
must_haves:
  truths:
    - "Each pagination strategy (offset_limit path, offset_limit query, page_number, page_size, cursor) is verified with mocked responses"
    - "Pagination loop combines records from multiple pages into a single result"
    - "max_pages safety limit stops pagination and emits a warning"
    - "At least one integration test runs chemi_amos_method_pagination end-to-end with VCR cassettes"
    - "All existing non-pagination tests continue to pass"
    - "Coverage threshold is 75% warn-only, dev/ and data.R excluded"
  artifacts:
    - path: "tests/testthat/test-pagination-execution.R"
      provides: "Mocked unit tests for pagination loop logic"
      min_lines: 60
    - path: "tests/testthat/test-pagination-integration.R"
      provides: "VCR-backed end-to-end pagination test"
      min_lines: 20
    - path: ".github/workflows/coverage-check.yml"
      provides: "Updated coverage config: 75% threshold, warn-only, exclusions"
      contains: "75"
    - path: "DESCRIPTION"
      provides: "mockery added to Suggests"
      contains: "mockery"
  key_links:
    - from: "tests/testthat/test-pagination-execution.R"
      to: "R/z_generic_request.R"
      via: "mockery::stub of generic_request internals"
      pattern: "mockery::stub"
    - from: "tests/testthat/test-pagination-integration.R"
      to: "R/chemi_amos_method_pagination.R"
      via: "direct function call within vcr::use_cassette"
      pattern: "chemi_amos_method_pagination"
---

<objective>
Create mocked execution tests for pagination strategies, a VCR integration test, and update coverage configuration.

Purpose: Verify pagination loop logic works correctly for all strategies (PAG-21), run an end-to-end paginated test (PAG-22), confirm no regression (PAG-23), and tune coverage thresholds per user decisions.
Output: test-pagination-execution.R, test-pagination-integration.R, updated coverage-check.yml, mockery in DESCRIPTION
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-pagination-tests-coverage-hardening/26-CONTEXT.md
@.planning/phases/26-pagination-tests-coverage-hardening/26-RESEARCH.md

<interfaces>
<!-- generic_request pagination signature from R/z_generic_request.R line 154 -->
```r
generic_request <- function(query = NULL, endpoint, method = "POST", server = 'ctx_burl',
                            batch_limit = NULL, auth = TRUE, tidy = TRUE, path_params = NULL,
                            content_type = "application/json", body_type = "json",
                            paginate = FALSE, max_pages = 100, pagination_strategy = NULL, ...)
```

<!-- Pagination execution block: lines 344-511 of z_generic_request.R -->
<!-- Key flow:
  1. if (paginate && !is.null(pagination_strategy) && pagination_strategy != "none")
  2. Builds strategy-specific next_req callback
  3. Calls httr2::req_perform_iterative(first_req, next_req, max_reqs=max_pages, on_error="return")
  4. Filters with httr2::resps_successes()
  5. Extracts body with httr2::resp_body_json() per response
  6. Warns if length(resps) >= max_pages
  7. Combines records, applies tidy formatting
-->

<!-- chemi_amos_method_pagination from R/chemi_amos_method_pagination.R -->
```r
chemi_amos_method_pagination <- function(limit, offset = 0, all_pages = TRUE) {
  result <- generic_request(
    query = limit,
    endpoint = "amos/method_pagination/",
    method = "GET",
    batch_limit = 1,
    server = "chemi_burl",
    auth = FALSE,
    tidy = FALSE,
    path_params = c(offset = offset),
    paginate = all_pages,
    max_pages = 100,
    pagination_strategy = "offset_limit"
  )
  return(result)
}
```

<!-- Pagination strategies in generic_request (lines 349-441):
  - "offset_limit" with path_params: increments offset path param
  - "page_number": increments pageNumber query param (1-indexed)
  - "page_size": increments page query param (0-indexed), Spring Boot Pageable
  - "offset_limit" without path_params: increments offset query param
  - "cursor": reads cursor from response, passes as query param
  - Unknown: cli::cli_abort()
-->

<!-- VCR config from tests/testthat/helper-vcr.R -->
<!-- Cassettes stored in tests/testthat/fixtures/ -->
<!-- API key filtered to <<<API_KEY>>> automatically -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mockery to DESCRIPTION Suggests and create execution tests</name>
  <files>DESCRIPTION, tests/testthat/test-pagination-execution.R</files>
  <action>
**Step 1: Add mockery to DESCRIPTION**
In DESCRIPTION file, add `mockery` to the `Suggests:` section alphabetically (after `httptest2`, before `testthat`). Use the format: `    mockery,`

**Step 2: Create test-pagination-execution.R**

This file tests the pagination loop logic in `generic_request()` using mockery to stub httr2 internals. The key challenge is that `generic_request()` calls `httr2::req_perform_iterative()` which has a complex signature. The recommended approach: mock at the `httr2::req_perform_iterative` level, returning a list of mock response objects, then mock `httr2::resps_successes` and `httr2::resp_body_json` to extract data from those mocks.

**Structure:**

```r
# Skip if mockery not available
skip_if_not_installed("mockery")
```

**Test 1: offset_limit with path_params combines pages** — Stub `httr2::req_perform_iterative` to return 2 mock response objects. Stub `httr2::resps_successes` to pass them through. Stub `httr2::resp_body_json` to return page data (page 1: records 1-3, page 2: records 4-5). Call `generic_request()` with `paginate=TRUE, pagination_strategy="offset_limit", path_params=c(offset=0)`. Verify the combined result has 5 records.

**Test 2: page_number strategy increments correctly** — Similar setup with 2 pages. Verify combined result.

**Test 3: cursor strategy follows cursor tokens** — Mock responses where first response includes a cursor token in the body. Verify cursor extraction logic.

**Test 4: empty page terminates loop** — Mock `req_perform_iterative` to return 1 response with empty body (list()). Verify result is empty (no error).

**Test 5: max_pages limit emits warning** — Mock `req_perform_iterative` to return exactly `max_pages` responses (set max_pages=2, return 2 responses). Use `expect_warning(..., "Pagination stopped at 2 page")` to verify the truncation warning is emitted.

**IMPORTANT mocking approach:** Since `generic_request` has complex setup (server URLs, auth, etc.), and we're testing the pagination logic specifically, consider testing from the wrapper level. Call `chemi_amos_method_pagination(limit=5, offset=0, all_pages=TRUE)` after stubbing `httr2::req_perform_iterative` inside `generic_request`. This avoids needing to set up server environment variables. Alternatively, set env vars in test setup:
```r
withr::local_envvar(chemi_burl = "https://fake.example.com/api/")
```

If mockery::stub proves too brittle with the complex httr2 pipeline, fall back to a simpler approach: use `local_mocked_bindings()` from testthat 3.0+ instead:
```r
local_mocked_bindings(
  req_perform_iterative = function(...) list(mock_resp1, mock_resp2),
  resps_successes = function(resps) resps,
  resp_body_json = function(resp, ...) resp$body,
  .package = "httr2"
)
```

Each mock response should be a simple list with a `$body` field containing the page data.
  </action>
  <verify>
```bash
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pagination-execution.R')"
```
  </verify>
  <done>Execution tests pass: offset_limit, page_number, cursor strategies verified with mocks; empty page termination works; max_pages warning emitted</done>
</task>

<task type="auto">
  <name>Task 2: Create integration test and update coverage configuration</name>
  <files>tests/testthat/test-pagination-integration.R, .github/workflows/coverage-check.yml</files>
  <action>
**Step 1: Create test-pagination-integration.R**

This file uses VCR cassettes to test `chemi_amos_method_pagination` end-to-end. The function uses `auth=FALSE` (AMOS endpoints don't need API key) and `server="chemi_burl"`, so the chemi server must be configured.

**Test structure:**

```r
test_that("chemi_amos_method_pagination fetches multiple pages", {
  # Ensure chemi server is configured
  chemi_server(1)  # Set production endpoint

  vcr::use_cassette("pagination_e2e_multipage", {
    result <- chemi_amos_method_pagination(
      limit = 5,
      offset = 0,
      all_pages = TRUE
    )

    expect_type(result, "list")
    expect_true(length(result) >= 5)
  })
})
```

**Test 1: Multi-page fetch** — Call with limit=5, offset=0, all_pages=TRUE. Use VCR cassette "pagination_e2e_multipage". Verify result is a list with at least 5 elements (confirming multiple pages were combined).

**Test 2: Last page termination** — Call with limit=100, offset=0, all_pages=TRUE. Use VCR cassette "pagination_e2e_lastpage". Verify it returns without error and returns a list. This exercises the "partial last page" termination logic.

**Test 3: max_pages safety (skip if not exposed)** — Since `chemi_amos_method_pagination` hardcodes max_pages=100, and we can't easily set max_pages=2 through the wrapper, call `generic_request()` directly with max_pages=2 and small limit to trigger the warning. Use VCR cassette "pagination_e2e_maxpages". Wrap in `expect_warning(..., "Pagination stopped")`. If recording this cassette is impractical (needs many real API pages), skip with `skip("max_pages test requires many API pages")`.

**Note on first run:** The first run will record cassettes from production. The chemi AMOS endpoint is public (no API key). Cassettes will be stored in `tests/testthat/fixtures/` per helper-vcr.R config. If the AMOS endpoint is unreachable during CI, tests should fail gracefully (VCR will error on missing cassette — this is expected; cassettes must be committed).

**Step 2: Update coverage-check.yml**

Modify `.github/workflows/coverage-check.yml` to implement user decisions:

1. Change threshold to single 75% value:
   ```r
   MINIMUM_COVERAGE <- 75
   ```

2. Change fail behavior to warn-only (never `quit(status = 1)`):
   ```r
   if (percent < MINIMUM_COVERAGE) {
     cat(sprintf("WARNING: Coverage (%.2f%%) is below target threshold (%.0f%%)\n", percent, MINIMUM_COVERAGE))
   } else {
     cat(sprintf("PASS: Coverage (%.2f%%) meets or exceeds target (%.0f%%)\n", percent, MINIMUM_COVERAGE))
   }
   ```

3. Exclude dev/ and R/data.R from coverage measurement:
   ```r
   cov <- covr::package_coverage(
     type = "tests",
     line_exclusions = list("R/data.R")
   )
   ```
   Note: `covr::package_coverage()` only measures files in `R/` by default, so `dev/` is already excluded. Only `R/data.R` needs explicit exclusion.

4. Update the PR comment section to reflect the single 75% threshold (remove WARNING_COVERAGE and TARGET_COVERAGE rows, simplify to one threshold row).

5. Remove the `quit(status = 1)` call entirely — coverage is informational only per user decision.

**Step 3: Run full test suite to verify no regression (PAG-23)**

After creating both test files, run the full test suite with `devtools::test()` to confirm all existing tests still pass alongside the new pagination tests.
  </action>
  <verify>
```bash
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pagination-integration.R')" && "C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "devtools::test()"
```
  </verify>
  <done>Integration test passes with VCR cassettes recorded, coverage-check.yml uses 75% warn-only threshold with R/data.R excluded, full test suite passes with no regression</done>
</task>

</tasks>

<verification>
```bash
# Run all three pagination test files
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pagination-execution.R')"
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pagination-integration.R')"

# Full regression check
"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "devtools::test()"
```
</verification>

<success_criteria>
- test-pagination-execution.R tests all pagination strategies with mocked responses
- test-pagination-integration.R runs chemi_amos_method_pagination with VCR cassettes
- max_pages warning behavior is verified (either mocked or integration)
- coverage-check.yml has 75% single threshold, warn-only, R/data.R excluded
- mockery is in DESCRIPTION Suggests
- Full test suite passes (no regression from PAG-23)
</success_criteria>

<output>
After completion, create `.planning/phases/26-pagination-tests-coverage-hardening/26-02-SUMMARY.md`
</output>
