---
phase: 21-stub-generation-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dev/endpoint_eval/07_stub_generation.R
  - tests/testthat/test-pipeline-stub-generation.R
  - tests/testthat/_snaps/pipeline-stub-generation.md
autonomous: true
requirements: [PAG-14, PAG-15, PAG-16]

must_haves:
  truths:
    - "Paginated endpoints generate stubs with paginate = all_pages in template call"
    - "Generated stubs expose all_pages = TRUE parameter at end of signature"
    - "Individual pagination params (offset, page, limit, etc.) remain in function signature with sensible defaults"
    - "Non-paginated endpoints produce identical stubs to current behavior"
  artifacts:
    - path: "dev/endpoint_eval/07_stub_generation.R"
      provides: "Pagination-aware stub generation logic"
      contains: "pagination_strategy"
    - path: "tests/testthat/test-pipeline-stub-generation.R"
      provides: "Tests for paginated and non-paginated stub generation"
      contains: "all_pages"
  key_links:
    - from: "dev/endpoint_eval/07_stub_generation.R:render_endpoint_stubs"
      to: "dev/endpoint_eval/07_stub_generation.R:build_function_stub"
      via: "pmap_chr passes pagination_strategy and pagination_metadata"
      pattern: "pagination_strategy = spec\\$pagination_strategy"
    - from: "dev/endpoint_eval/07_stub_generation.R:build_function_stub"
      to: "R/z_generic_request.R:generic_request"
      via: "generated stub code includes paginate argument"
      pattern: "paginate = all_pages"
---

<objective>
Generate auto-paginating stubs for paginated endpoints by connecting Phase 19 pagination metadata to Phase 20 template parameters through the stub generation pipeline.

Purpose: Paginated endpoints should auto-fetch all pages by default while letting users manually paginate when needed.
Output: Updated `build_function_stub()` and `render_endpoint_stubs()` with pagination-aware code generation, plus tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-stub-generation-integration/21-RESEARCH.md
@dev/endpoint_eval/07_stub_generation.R
@tests/testthat/test-pipeline-stub-generation.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plumb pagination metadata through pipeline and generate pagination-aware stubs</name>
  <files>dev/endpoint_eval/07_stub_generation.R</files>
  <action>
This task modifies two functions in 07_stub_generation.R to pass pagination metadata and generate pagination-aware stubs.

**Part A: Plumb pagination columns through render_endpoint_stubs() to build_function_stub()**

1. Add `pagination_strategy` and `pagination_metadata` to the `pmap_chr` list at line ~1108:
   ```r
   pagination_strategy = spec$pagination_strategy,
   pagination_metadata = spec$pagination_metadata
   ```

2. Add these params to the anonymous function signature inside `pmap_chr` (line ~1125).

3. Pass them through to `build_function_stub()` call with safe defaults:
   ```r
   pagination_strategy = pagination_strategy %|NA|% "none",
   pagination_metadata = pagination_metadata
   ```

4. Add `pagination_strategy = "none"` and `pagination_metadata = NULL` to `build_function_stub()` function signature (line ~153).

**Part B: Generate all_pages parameter and pagination call arguments in build_function_stub()**

After all three endpoint-type branches (is_body_only, is_query_only, standard) finish building `fn_signature` and `param_docs` but BEFORE building `example_call` (line ~351), add a pagination block:

```r
# =========================================================================
# Pagination Parameter Generation (Phase 21)
# =========================================================================
# For paginated endpoints, add all_pages parameter and pagination call args
pagination_call_params <- ""

if (!isTRUE(pagination_strategy == "none") && !is.null(pagination_strategy) && !is.na(pagination_strategy)) {
  # 1. Set sensible defaults for pagination params already in signature
  #    (offset -> 0, page -> 0, pageNumber -> 1)
  pag_params <- if (!is.null(pagination_metadata) && !is.null(pagination_metadata$params)) {
    pagination_metadata$params
  } else {
    character(0)
  }

  fn_signature_safe_pag <- fn_signature %|NA|% ""
  if ("offset" %in% pag_params && grepl("\\boffset\\b", fn_signature_safe_pag)) {
    # Replace bare "offset" (no default) with "offset = 0"
    fn_signature <- gsub("\\boffset(?!\\s*=)", "offset = 0", fn_signature, perl = TRUE)
  }
  if ("page" %in% pag_params && grepl("\\bpage\\b", fn_signature_safe_pag) && !grepl("\\bpageNumber\\b", fn_signature_safe_pag)) {
    fn_signature <- gsub("\\bpage(?!\\s*=|Number)", "page = 0", fn_signature, perl = TRUE)
  }
  if ("pageNumber" %in% pag_params && grepl("\\bpageNumber\\b", fn_signature_safe_pag)) {
    fn_signature <- gsub("\\bpageNumber(?!\\s*=)", "pageNumber = 1", fn_signature, perl = TRUE)
  }

  # 2. Append all_pages = TRUE to end of signature
  fn_signature_check <- fn_signature %|NA|% ""
  if (nzchar(fn_signature_check)) {
    fn_signature <- paste0(fn_signature, ", all_pages = TRUE")
  } else {
    fn_signature <- "all_pages = TRUE"
  }

  # 3. Add @param all_pages documentation
  param_docs <- paste0(
    param_docs,
    "#' @param all_pages Logical; if TRUE (default), automatically fetches all pages. If FALSE, returns a single page using manual pagination parameters.\n"
  )

  # 4. Build pagination call params string (inserted into glue templates)
  pagination_call_params <- paste0(
    ",\n    paginate = all_pages",
    ",\n    max_pages = 100",
    ',\n    pagination_strategy = "', pagination_strategy, '"'
  )
}
```

**Part C: Insert pagination_call_params into ALL glue template patterns**

There are multiple glue template call sites for `generic_request()`, `generic_chemi_request()`, and `generic_cc_request()`. For each, insert `{pagination_call_params}` right before the closing parenthesis of the template call. The variable is an empty string for non-paginated endpoints, so it changes nothing for them.

Specific locations to modify (approximate line numbers from current file):

1. **Resolver wrapper** (~line 479): Add `{pagination_call_params}` after `tidy = FALSE` in generic_chemi_request call
2. **Raw text body** (~line 540): Add after `body_type = "raw_text"` in generic_request call
3. **Simple body string_array** (~line 602): Add after `batch_limit = ...` in generic_request call
4. **Simple body string** (~line 617): Add after `batch_limit = ...` in generic_request call
5. **Body-only chemi** (~line 705): Add after `tidy = FALSE` in generic_chemi_request call
6. **Body-only generic_request** (~line 746): Add after `body = body{content_type_call}` in generic_request call
7. **Query-only generic_request** (~line 774): Add after `{combined_calls}` in generic_request call
8. **Query-only generic_chemi_request** (~line 790): Add after `tidy = FALSE` in generic_chemi_request call
9. **Query-only generic_cc_request** (~line 804): Add after `{combined_calls}` in generic_cc_request call
10. **Chemi GET query-only** (~line 852): Add after `{direct_params}` in generic_request call
11. **Standard with params generic_request** (~line 868): Add after `{combined_calls}` in generic_request call
12. **Standard with params generic_chemi_request** (~line 886): Add after `tidy = FALSE` in generic_chemi_request call
13. **No params generic_request** (~line 927): Add after `{extra_params}` in generic_request call
14. **No params generic_chemi_request** (~line 944): Add after `tidy = FALSE` in generic_chemi_request call

For each glue template, the insertion point is BEFORE the closing `)` of the template function call. The pattern is:
```r
# Before:
    batch_limit = {batch_limit_code}{chemi_server_params}
  )
# After:
    batch_limit = {batch_limit_code}{chemi_server_params}{pagination_call_params}
  )
```

IMPORTANT: `pagination_call_params` is "" for non-paginated endpoints, so these changes are inert for all existing stubs. Only paginated endpoints get the extra arguments.

IMPORTANT: Do NOT add `paginate_mode <- all_pages` variable. Per user decision, pass `paginate = all_pages` directly (simpler).
  </action>
  <verify>
    <automated>"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('tests/testthat/helper-pipeline.R'); source_pipeline_files(); defaults <- list(fn='test_fn', endpoint='test/', method='GET', title='Test', batch_limit=1, path_param_info=list(has_path_params=TRUE, has_any_path_params=TRUE, primary_param='limit', fn_signature='limit, offset', param_docs='#\\' @param limit Limit\\n#\\' @param offset Offset\\n', path_params_call=',\\n    path_params = c(offset = offset)', primary_example='10'), query_param_info=list(has_params=FALSE, primary_param=NULL, fn_signature='', param_docs='', params_call='', params_code='', primary_example=NA), body_param_info=list(has_params=FALSE, primary_param=NULL, fn_signature='', param_docs='', primary_example=NA), content_type='application/json', config=list(wrapper_function='generic_request', example_query='10', lifecycle_badge='experimental'), needs_resolver=FALSE, body_schema_type='unknown', deprecated=FALSE, response_schema_type='object', request_type='path', pagination_strategy='offset_limit', pagination_metadata=list(params=c('limit','offset'))); stub <- do.call(build_function_stub, defaults); stopifnot(grepl('all_pages = TRUE', stub)); stopifnot(grepl('paginate = all_pages', stub)); stopifnot(grepl('offset = 0', stub)); cat('PASS: paginated stub generated correctly\\n')"</automated>
    <manual>Verify the generated stub code contains paginate, max_pages, pagination_strategy arguments</manual>
  </verify>
  <done>
    - build_function_stub() accepts pagination_strategy and pagination_metadata parameters
    - render_endpoint_stubs() passes pagination columns to build_function_stub()
    - Paginated endpoints generate stubs with all_pages = TRUE in signature, paginate = all_pages in call
    - Pagination params get sensible defaults (offset=0, page=0, pageNumber=1)
    - Non-paginated endpoints: pagination_call_params is empty string, zero code change in output
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pagination stub generation tests</name>
  <files>tests/testthat/test-pipeline-stub-generation.R, tests/testthat/_snaps/pipeline-stub-generation.md</files>
  <action>
Add a new test section to tests/testthat/test-pipeline-stub-generation.R AFTER the existing "Function Stub Generation Tests" section and BEFORE the "Environment Tracking Tests" section.

Add the following tests inside a `describe("build_function_stub pagination", { ... })` block:

1. **"paginated endpoint adds all_pages parameter to signature"**
   - Create defaults with `pagination_strategy = "offset_limit"` and `pagination_metadata = list(params = c("limit", "offset"))`
   - Use path_param_info with `fn_signature = "limit, offset"`, `has_path_params = TRUE`, `has_any_path_params = TRUE`, `primary_param = "limit"`, `path_params_call = ',\n    path_params = c(offset = offset)'`, `param_docs = "#' @param limit ...\n#' @param offset ...\n"`, `primary_example = "10"`
   - Set `request_type = "path"`, `batch_limit = 1`, `method = "GET"`
   - Assert: stub contains `all_pages = TRUE` in function signature
   - Assert: stub contains `@param all_pages` in roxygen docs
   - Assert: stub contains `paginate = all_pages`
   - Assert: stub contains `max_pages = 100`
   - Assert: stub contains `pagination_strategy = "offset_limit"`

2. **"paginated endpoint sets offset default to 0"**
   - Same setup as test 1
   - Assert: stub contains `offset = 0` in signature (not bare `offset`)

3. **"paginated endpoint with page_number strategy sets pageNumber default to 1"**
   - Create defaults with `pagination_strategy = "page_number"`, `pagination_metadata = list(params = c("pageNumber"))`
   - Use query_param_info with `fn_signature = "studyType, pageNumber"`, `has_params = TRUE`, `primary_param = "studyType"`, etc.
   - Set `request_type = "path"` (has path params)
   - Assert: stub contains `pageNumber = 1`
   - Assert: stub contains `all_pages = TRUE`

4. **"non-paginated endpoint is unaffected"**
   - Create defaults with `pagination_strategy = "none"`, `pagination_metadata = NULL`
   - Use same defaults as existing "generates generic_request() call" test
   - Capture stub output
   - Assert: stub does NOT contain `all_pages`
   - Assert: stub does NOT contain `paginate`
   - Assert: stub does NOT contain `max_pages`
   - Assert: stub does NOT contain `pagination_strategy`

5. **"non-paginated endpoint with explicit none produces identical output"**
   - Create two stubs: one with `pagination_strategy = "none"` explicitly, one without passing pagination params (relying on defaults)
   - Assert: both produce identical output (regression test)

6. **Snapshot test: "snapshot test - paginated offset_limit endpoint"**
   - Same setup as test 1
   - Snapshot key parts: function signature line and generic_request call block

Also update the `create_stub_defaults()` helper to include `pagination_strategy = "none"` and `pagination_metadata = NULL` so existing tests continue to work without modification.

Delete the snapshot file `tests/testthat/_snaps/pipeline-stub-generation.md` if it exists so snapshots are re-recorded fresh (some existing snapshots may change if the defaults helper changes).
  </action>
  <verify>
    <automated>"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pipeline-stub-generation.R')"</automated>
    <manual>Check test output shows all pagination tests passing alongside existing tests</manual>
  </verify>
  <done>
    - At least 5 new tests covering paginated stub generation
    - Non-paginated regression test confirms zero impact
    - All existing tests still pass
    - Snapshot tests capture pagination-specific output
  </done>
</task>

</tasks>

<verification>
1. Run full stub generation test suite: `"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "testthat::test_file('tests/testthat/test-pipeline-stub-generation.R')"`
2. Verify non-paginated stubs are identical by checking the "non-paginated endpoint is unaffected" test passes
3. Verify paginated stubs contain: `all_pages = TRUE`, `paginate = all_pages`, `max_pages = 100`, `pagination_strategy = "..."`
</verification>

<success_criteria>
- build_function_stub() with pagination_strategy = "offset_limit" produces a stub containing `paginate = all_pages, max_pages = 100, pagination_strategy = "offset_limit"`
- Generated stubs have `all_pages = TRUE` as the LAST parameter in the function signature
- Pagination params get defaults: offset = 0, page = 0, pageNumber = 1
- build_function_stub() with pagination_strategy = "none" produces identical output to current behavior
- All tests pass (new pagination tests + existing regression tests)
</success_criteria>

<output>
After completion, create `.planning/phases/21-stub-generation-integration/21-01-SUMMARY.md`
</output>
