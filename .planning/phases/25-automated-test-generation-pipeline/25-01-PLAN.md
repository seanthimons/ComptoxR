---
phase: 25-automated-test-generation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dev/detect_test_gaps.R
  - dev/test_manifest.json
  - dev/reports/.gitkeep
autonomous: true
requirements:
  - AUTO-01
  - AUTO-05

must_haves:
  truths:
    - "Running `Rscript dev/detect_test_gaps.R` outputs a JSON report listing functions without test files or with empty test skeletons"
    - "Non-API utility functions (those NOT calling generic_request/generic_chemi_request/generic_cc_request) are excluded from gap detection"
    - "Test files with no test_that() blocks are reported as gaps with reason 'empty_test_file'"
    - "The manifest at dev/test_manifest.json tracks test files as 'generated' or 'protected'"
    - "Running the script locally prints a summary to stdout and writes a report to dev/reports/"
    - "Running the script in CI writes GITHUB_OUTPUT variables (gaps_found, gaps_count)"
  artifacts:
    - path: "dev/detect_test_gaps.R"
      provides: "Gap detection script with AST-based function call detection"
      min_lines: 100
    - path: "dev/test_manifest.json"
      provides: "Test file tracking manifest (generated vs protected status)"
      contains: "version"
    - path: "dev/reports/.gitkeep"
      provides: "Empty directory for gap report output"
  key_links:
    - from: "dev/detect_test_gaps.R"
      to: "R/*.R"
      via: "parse() + all.names() AST walking to detect generic_request calls"
      pattern: "generic_(request|chemi_request|cc_request)"
    - from: "dev/detect_test_gaps.R"
      to: "dev/test_manifest.json"
      via: "read_test_manifest() helper reads manifest to check protected status"
      pattern: "read_test_manifest"
    - from: "dev/detect_test_gaps.R"
      to: "GITHUB_OUTPUT"
      via: "Conditional output: CI writes to GITHUB_OUTPUT, local prints to stdout"
      pattern: "GITHUB_OUTPUT"
---

<objective>
Create the test gap detection script and test manifest system.

Purpose: AUTO-01 requires a script that identifies exported API-calling functions lacking test files. AUTO-05 requires coverage threshold awareness (the manifest enables distinguishing generated from protected test files). The manifest also enables the overwrite protection system required across AUTO-02/AUTO-06.
Output: `dev/detect_test_gaps.R` script, `dev/test_manifest.json` manifest file, `dev/reports/` directory
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-automated-test-generation-pipeline/25-CONTEXT.md
@.planning/phases/25-automated-test-generation-pipeline/25-RESEARCH.md

<interfaces>
<!-- Key patterns the executor needs from existing codebase -->

From dev/generate_tests.R (existing test generator pattern):
```r
# Function file naming: R/ct_hazard.R, R/chemi_toxprint.R, R/cc_*.R
# Test file naming: tests/testthat/test-ct_hazard.R
# Function name = tools::file_path_sans_ext(basename(r_file))
# Existing functions: extract_function_formals(), extract_tidy_flag(), get_test_value_for_param()
# Entry point: generate_all_tests(r_dir, test_dir, force)
```

From dev/calculate_coverage.R (GITHUB_OUTPUT pattern):
```r
if (Sys.getenv("GITHUB_OUTPUT") != "") {
  output_file <- Sys.getenv("GITHUB_OUTPUT")
  cat(sprintf("key=%s\n", value), file = output_file, append = TRUE)
}
```

From R/z_generic_request.R (the functions that mark API wrappers):
```r
# Functions to detect: generic_request(), generic_chemi_request(), generic_cc_request()
# Detection confirms file is an API wrapper (not a utility function)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gap detection script and manifest helpers</name>
  <files>dev/detect_test_gaps.R, dev/test_manifest.json, dev/reports/.gitkeep</files>
  <action>
Create `dev/detect_test_gaps.R` with the following components:

**Manifest helpers** (used by both this script and generate_tests.R in Plan 02):
- `read_test_manifest()` - reads `dev/test_manifest.json`, returns list with version and files. If file doesn't exist, returns default structure `list(version = "1.0", updated = timestamp, files = list())`.
- `write_test_manifest(manifest)` - writes manifest to `dev/test_manifest.json` with `pretty = TRUE, auto_unbox = TRUE`.
- `is_protected(test_filename, manifest)` - checks if a test file has status "protected" in the manifest.

**Detection helpers:**
- `calls_generic_request(file_path)` - uses `parse(file = file_path)` then `all.names()` on each expression. Returns TRUE if any of `generic_request`, `generic_chemi_request`, `generic_cc_request` appear. Wrap in tryCatch with FALSE fallback for unparseable files.
- `has_real_tests(test_file_path)` - reads file lines, returns TRUE if any line matches `grepl("test_that\\s*\\(", line)`. Returns FALSE if file doesn't exist.
- `detect_stale_protected(manifest)` - for each protected file in manifest, check if the underlying R/ function file still exists and still calls generic_request. Return list of stale entries with reason.

**Main function `detect_gaps()`:**
1. Load libraries: cli, fs, jsonlite (use `library()` at top of script like existing dev/ scripts)
2. Scan `R/` for files matching `^(ct_|chemi_|cc_)[^.]+\\.R$` using `fs::dir_ls()` with regexp
3. For each file: extract function name from filename, check if it calls generic_request
4. For API wrapper files, check gap conditions:
   - No test file at `tests/testthat/test-{function_name}.R` -> reason: "no_test_file"
   - Test file exists but `has_real_tests()` returns FALSE -> reason: "empty_test_file"
5. Read manifest and check for stale protected files (warn but don't count as gaps)
6. Write JSON report to `dev/reports/test_gaps_{YYYYMMDD}.json` with structure: list of objects with `function_name`, `file_path`, `test_file`, `reason`
7. Write GITHUB_OUTPUT variables if in CI: `gaps_found` (true/false string), `gaps_count` (integer)
8. Print cli summary to stdout: "Found N gaps", list of gap functions grouped by reason
9. Return gaps invisibly

**Script entry point:** At bottom, use pattern from existing scripts:
```r
if (!interactive()) {
  detect_gaps()
}
```

Create `dev/test_manifest.json` with initial structure:
```json
{
  "version": "1.0",
  "updated": "2026-02-28T00:00:00Z",
  "files": {}
}
```

Create `dev/reports/.gitkeep` as empty file to ensure the reports directory exists in git.

**Important:** Use `here::here()` for all path construction (consistent with existing dev/ scripts). Use `cli` package for all user-facing messages. Do NOT use `library(here)` — call `here::here()` directly (some dev scripts do this).

Actually, check the existing `dev/calculate_coverage.R` which uses `library(here)` at the top. Follow that same pattern — use `library(here)` and `library(jsonlite)` at top.
  </action>
  <verify>
    <automated>"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "source('dev/detect_test_gaps.R'); gaps <- detect_gaps(); cat('Gaps found:', length(gaps), '\n'); stopifnot(is.list(gaps))"</automated>
  </verify>
  <done>
  - `dev/detect_test_gaps.R` exists and runs without error
  - Script detects functions calling generic_request that lack test files
  - Non-API utility functions are excluded
  - Empty test files (no test_that blocks) are flagged as gaps
  - JSON report written to dev/reports/
  - GITHUB_OUTPUT variables written when in CI environment
  - `dev/test_manifest.json` exists with valid JSON structure
  - `read_test_manifest()` and `write_test_manifest()` work correctly
  </done>
</task>

</tasks>

<verification>
1. Run `Rscript dev/detect_test_gaps.R` — should complete without errors and print gap summary
2. Check `dev/reports/` for a dated JSON report file
3. Verify the gap report contains only API wrapper functions (ct_*, chemi_*, cc_*)
4. Verify `dev/test_manifest.json` is valid JSON with version field
5. Run `Rscript -e "source('dev/detect_test_gaps.R'); m <- read_test_manifest(); stopifnot(m$version == '1.0')"` — manifest read works
</verification>

<success_criteria>
- `Rscript dev/detect_test_gaps.R` runs cleanly and outputs gap count
- Gap report JSON is well-formed and excludes non-API functions
- Manifest system (read/write/is_protected) works end-to-end
- Script handles both CI and local execution modes
</success_criteria>

<output>
After completion, create `.planning/phases/25-automated-test-generation-pipeline/25-01-SUMMARY.md`
</output>
