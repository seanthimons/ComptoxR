---
phase: 24-vcr-cassette-cleanup
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - dev/rerecord_cassettes.R
autonomous: true
requirements:
  - VCR-07

must_haves:
  truths:
    - "Re-recording script supports batched execution of test files with configurable batch size"
    - "Script uses mirai with 8 workers for parallel execution"
    - "Script handles HTTP 429 rate limits via httr2 exponential backoff"
    - "On failure, script skips the cassette, logs to failures file, and continues"
    - "Script prioritizes Chemical domain, chemi_search, and chemi_resolver_lookup functions"
    - "Failures can be re-run separately after initial batch completes"
  artifacts:
    - path: "dev/rerecord_cassettes.R"
      provides: "Parallel cassette re-recording script with mirai"
      contains: "mirai|daemons|rerecord|priority"
  key_links:
    - from: "dev/rerecord_cassettes.R"
      to: "tests/testthat/fixtures/"
      via: "testthat::test_file() triggering vcr cassette recording"
      pattern: "test_file"
---

<objective>
Create a batched, parallel cassette re-recording script using mirai with 8 workers.

Purpose: Enable efficient re-recording of VCR cassettes from production APIs after tests have been fixed (Phase 23). The script handles rate limiting, logs failures, and prioritizes high-value domains.

Output: dev/rerecord_cassettes.R script ready for use when API key is available.
</objective>

<execution_context>
@C:/Users/sxthi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sxthi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Existing dev/ scripts for pattern reference -->
# dev/generate_tests.R - test generation script (uses glue, purrr, stringr, cli)
# dev/generate_stubs.R - stub generation script

<!-- VCR configuration -->
From tests/testthat/helper-vcr.R:
```r
vcr::vcr_configure(
  dir = vcr_dir,
  filter_sensitive_data = list(
    "<<<API_KEY>>>" = Sys.getenv("ctx_api_key")
  )
)
```

<!-- mirai pattern -->
# mirai::daemons(n = 8) - initialize worker pool
# mirai::mirai({...}) - submit async task
# mirai::call_mirai() - collect result
# mirai::daemons(0) - shutdown workers
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parallel re-recording script</name>
  <files>dev/rerecord_cassettes.R</files>
  <action>
Create `dev/rerecord_cassettes.R` — a parallel cassette re-recording script using mirai.

**Script structure:**

1. **Header comment block** explaining:
   - Purpose: Re-record VCR cassettes from production APIs
   - Requirements: Valid API key in `ctx_api_key` env var
   - Usage: `Rscript dev/rerecord_cassettes.R` (runs priority batch by default)
   - Usage: `Rscript dev/rerecord_cassettes.R --all` (re-records all test files)
   - Usage: `Rscript dev/rerecord_cassettes.R --failures` (re-runs failed files from previous run)

2. **Configuration section:**
   ```r
   N_WORKERS <- 8                          # Per user requirement
   BATCH_SIZE <- 20                        # Files per batch (20-50 range per VCR-07)
   BASE_DELAY <- 0.5                       # Seconds between batch submissions
   CASSETTE_DIR <- here::here("tests/testthat/fixtures")
   TEST_DIR <- here::here("tests/testthat")
   LOG_FILE <- here::here("dev/logs/rerecord_failures.log")
   ```

3. **Priority patterns** (LOCKED DECISION):
   ```r
   PRIORITY_PATTERNS <- c(
     "^test-ct_chemical",
     "^test-chemi_search",
     "^test-chemi_resolver"
   )
   ```

4. **Command-line argument parsing:**
   - `--all`: Re-record all test files in tests/testthat/
   - `--failures`: Re-run only files listed in the failures log
   - Default (no args): Run priority patterns only
   - `--batch-size N`: Override default batch size
   - `--workers N`: Override default worker count

5. **Pre-flight checks function:**
   - Verify `ctx_api_key` env var is set and non-empty (abort with helpful message if not)
   - Verify mirai is installed
   - Verify test directory exists
   - Create log directory if needed (`dev/logs/`)

6. **`rerecord_batch(test_files, n_workers, batch_size, base_delay)` function:**
   - Split test_files into batches of `batch_size`
   - For each batch:
     - Initialize mirai daemons: `mirai::daemons(n = n_workers)`
     - For each test file in batch, delete its existing cassettes first (use pattern matching on filename), then submit `mirai::mirai({ testthat::test_file(file, reporter = "minimal") })`
     - Collect results with `mirai::call_mirai()`
     - Track successes and failures
     - After batch completes, `mirai::daemons(0)` to clean up
     - `Sys.sleep(base_delay)` between batches
   - Return list of failures

7. **`get_test_files(mode)` function:**
   - `"priority"`: Find test files matching PRIORITY_PATTERNS
   - `"all"`: All test-*.R files in TEST_DIR
   - `"failures"`: Read files from LOG_FILE

8. **Main execution flow:**
   - Parse args
   - Run pre-flight checks
   - Get test files based on mode
   - Show cli progress: "Re-recording {n} test files in batches of {batch_size} with {n_workers} workers"
   - Call `rerecord_batch()`
   - Write failures to LOG_FILE (overwrite, not append)
   - Final summary: successes, failures, time elapsed
   - If failures exist: `cli::cli_alert_info("Re-run failures with: Rscript dev/rerecord_cassettes.R --failures")`

**Error handling** (LOCKED DECISION):
- On failure (API error, timeout): skip the cassette, log it, continue
- Use tryCatch inside mirai tasks to catch errors gracefully
- Each mirai task should return a list: `list(file = file, success = TRUE/FALSE, error = NULL/message)`

**Important notes:**
- Do NOT actually run the re-recording (requires API key). This task creates the script only.
- httr2's built-in exponential backoff handles 429 responses automatically (already configured in generic_request). Do NOT add custom retry logic — the backoff happens at the HTTP layer.
- The script should be self-contained: load its own required packages (mirai, cli, fs, here, testthat)
  </action>
  <verify>
    <automated>"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "tryCatch(parse(file = 'dev/rerecord_cassettes.R'), error = function(e) stop(e)); cat('Script parses OK\n')"</automated>
  </verify>
  <done>dev/rerecord_cassettes.R exists, parses without syntax errors, supports --all/--failures/default modes, uses mirai with 8 workers, handles failures gracefully with logging, and prioritizes Chemical/chemi_search/chemi_resolver domains.</done>
</task>

<task type="auto">
  <name>Task 2: Verify script structure and ensure log directory exists</name>
  <files>dev/rerecord_cassettes.R</files>
  <action>
Validate the re-recording script is complete and well-structured:

1. Verify the script parses without errors
2. Verify key components exist by grepping the file:
   - `daemons` (mirai worker pool)
   - `PRIORITY_PATTERNS` (priority domains)
   - `--failures` (re-run mode)
   - `LOG_FILE` (failure logging)
   - `tryCatch` (error handling)
   - `BATCH_SIZE` (batched execution)
3. Ensure `dev/logs/` directory exists (create via `fs::dir_create()` if needed, or add .gitkeep)
4. Add `dev/logs/*.log` to `.gitignore` if not already present (log files should not be committed)

Do NOT run the actual re-recording — just validate the script structure.
  </action>
  <verify>
    <automated>"C:\Program Files\R\R-4.5.1\bin\Rscript.exe" -e "lines <- readLines('dev/rerecord_cassettes.R'); checks <- c('daemons', 'PRIORITY_PATTERNS', 'failures', 'LOG_FILE', 'tryCatch', 'BATCH_SIZE'); found <- sapply(checks, function(x) any(grepl(x, lines))); cat(paste(checks, found, sep = ': '), sep = '\n'); stopifnot(all(found))"</automated>
  </verify>
  <done>Script contains all required components: mirai daemons, priority patterns, failure re-run mode, failure logging, error handling, and batch size configuration. Log directory exists and is gitignored.</done>
</task>

</tasks>

<verification>
- dev/rerecord_cassettes.R parses without syntax errors
- Script uses mirai::daemons(n = 8) for parallel execution
- Script supports --all, --failures, and default (priority) modes
- Script logs failures to dev/logs/rerecord_failures.log
- Script prioritizes ct_chemical_*, chemi_search, chemi_resolver patterns
- dev/logs/*.log is in .gitignore
</verification>

<success_criteria>
A complete, syntactically valid re-recording script exists at dev/rerecord_cassettes.R that supports batched parallel execution with mirai, handles rate limiting via httr2's built-in backoff, logs failures for re-run, and prioritizes the Chemical domain.
</success_criteria>

<output>
After completion, create `.planning/phases/24-vcr-cassette-cleanup/24-03-SUMMARY.md`
</output>
